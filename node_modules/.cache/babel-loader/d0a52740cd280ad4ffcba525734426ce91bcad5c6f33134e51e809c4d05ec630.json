{"ast":null,"code":"// created 2024-09-13T06:42:45.675Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0ca3917bee1eee342d64c631cb1dbaac37b167d848887d59f6d68328dc99ac09\nvar COMPRESSED$1 = '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';\nconst FENCED = new Map([[8217, \"apostrophe\"], [8260, \"fraction slash\"], [12539, \"middle dot\"]]);\nconst NSM_MAX = 4;\nfunction decode_arithmetic(bytes) {\n  let pos = 0;\n  function u16() {\n    return bytes[pos++] << 8 | bytes[pos++];\n  }\n\n  // decode the frequency table\n  let symbol_count = u16();\n  let total = 1;\n  let acc = [0, 1]; // first symbol has frequency 1\n  for (let i = 1; i < symbol_count; i++) {\n    acc.push(total += u16());\n  }\n\n  // skip the sized-payload that the last 3 symbols index into\n  let skip = u16();\n  let pos_payload = pos;\n  pos += skip;\n  let read_width = 0;\n  let read_buffer = 0;\n  function read_bit() {\n    if (read_width == 0) {\n      // this will read beyond end of buffer\n      // but (undefined|0) => zero pad\n      read_buffer = read_buffer << 8 | bytes[pos++];\n      read_width = 8;\n    }\n    return read_buffer >> --read_width & 1;\n  }\n  const N = 31;\n  const FULL = 2 ** N;\n  const HALF = FULL >>> 1;\n  const QRTR = HALF >> 1;\n  const MASK = FULL - 1;\n\n  // fill register\n  let register = 0;\n  for (let i = 0; i < N; i++) register = register << 1 | read_bit();\n  let symbols = [];\n  let low = 0;\n  let range = FULL; // treat like a float\n  while (true) {\n    let value = Math.floor(((register - low + 1) * total - 1) / range);\n    let start = 0;\n    let end = symbol_count;\n    while (end - start > 1) {\n      // binary search\n      let mid = start + end >>> 1;\n      if (value < acc[mid]) {\n        end = mid;\n      } else {\n        start = mid;\n      }\n    }\n    if (start == 0) break; // first symbol is end mark\n    symbols.push(start);\n    let a = low + Math.floor(range * acc[start] / total);\n    let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n    while (((a ^ b) & HALF) == 0) {\n      register = register << 1 & MASK | read_bit();\n      a = a << 1 & MASK;\n      b = b << 1 & MASK | 1;\n    }\n    while (a & ~b & QRTR) {\n      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n      a = a << 1 ^ HALF;\n      b = (b ^ HALF) << 1 | HALF | 1;\n    }\n    low = a;\n    range = 1 + b - a;\n  }\n  let offset = symbol_count - 4;\n  return symbols.map(x => {\n    // index into payload\n    switch (x - offset) {\n      case 3:\n        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 2:\n        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 1:\n        return offset + bytes[pos_payload++];\n      default:\n        return x - 1;\n    }\n  });\n}\n\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n  let pos = 0;\n  return () => v[pos++];\n}\nfunction read_compressed_payload(s) {\n  return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\nfunction unsafe_atob(s) {\n  let lookup = [];\n  [...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\n  let n = s.length;\n  let ret = new Uint8Array(6 * n >> 3);\n  for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\n    carry = carry << 6 | lookup[s.charCodeAt(i)];\n    width += 6;\n    if (width >= 8) {\n      ret[pos++] = carry >> (width -= 8);\n    }\n  }\n  return ret;\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n  return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n  let v = Array(n);\n  for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n  return v;\n}\n\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next) {\n  let prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let ret = [];\n  while (true) {\n    let x = next();\n    let n = next();\n    if (!n) break;\n    prev += x;\n    for (let i = 0; i < n; i++) {\n      ret.push(prev + i);\n    }\n    prev += n + 1;\n  }\n  return ret;\n}\nfunction read_sorted_arrays(next) {\n  return read_array_while(() => {\n    let v = read_sorted(next);\n    if (v.length) return v;\n  });\n}\n\n// returns map of x => ys\nfunction read_mapped(next) {\n  let ret = [];\n  while (true) {\n    let w = next();\n    if (w == 0) break;\n    ret.push(read_linear_table(w, next));\n  }\n  while (true) {\n    let w = next() - 1;\n    if (w < 0) break;\n    ret.push(read_replacement_table(w, next));\n  }\n  return ret.flat();\n}\n\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n  let v = [];\n  while (true) {\n    let x = next(v.length);\n    if (!x) break;\n    v.push(x);\n  }\n  return v;\n}\n\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n  let m = Array(n).fill().map(() => []);\n  for (let i = 0; i < w; i++) {\n    read_deltas(n, next).forEach((x, j) => m[j].push(x));\n  }\n  return m;\n}\n\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n  let dx = 1 + next();\n  let dy = next();\n  let vN = read_array_while(next);\n  let m = read_transposed(vN.length, 1 + w, next);\n  return m.flatMap((v, i) => {\n    let [x, ...ys] = v;\n    return Array(vN[i]).fill().map((_, j) => {\n      let j_dy = j * dy;\n      return [x + j * dx, ys.map(y => y + j_dy)];\n    });\n  });\n}\n\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n  let n = 1 + next();\n  let m = read_transposed(n, 1 + w, next);\n  return m.map(v => [v[0], v.slice(1)]);\n}\nfunction read_trie(next) {\n  let ret = [];\n  let sorted = read_sorted(next);\n  expand(decode([]), []);\n  return ret; // not sorted\n  function decode(Q) {\n    // characters that lead into this node\n    let S = next(); // state: valid, save, check\n    let B = read_array_while(() => {\n      // buckets leading to new nodes\n      let cps = read_sorted(next).map(i => sorted[i]);\n      if (cps.length) return decode(cps);\n    });\n    return {\n      S,\n      B,\n      Q\n    };\n  }\n  function expand(_ref, cps, saved) {\n    let {\n      S,\n      B\n    } = _ref;\n    if (S & 4 && saved === cps[cps.length - 1]) return;\n    if (S & 2) saved = cps[cps.length - 1];\n    if (S & 1) ret.push(cps);\n    for (let br of B) {\n      for (let cp of br.Q) {\n        expand(br, [...cps, cp], saved);\n      }\n    }\n  }\n}\nfunction hex_cp(cp) {\n  return cp.toString(16).toUpperCase().padStart(2, '0');\n}\nfunction quote_cp(cp) {\n  return `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\nfunction explode_cp(s) {\n  // this is about 2x faster\n  let cps = [];\n  for (let pos = 0, len = s.length; pos < len;) {\n    let cp = s.codePointAt(pos);\n    pos += cp < 0x10000 ? 1 : 2;\n    cps.push(cp);\n  }\n  return cps;\n}\nfunction str_from_cps(cps) {\n  const chunk = 4096;\n  let len = cps.length;\n  if (len < chunk) return String.fromCodePoint(...cps);\n  let buf = [];\n  for (let i = 0; i < len;) {\n    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n  }\n  return buf.join('');\n}\nfunction compare_arrays(a, b) {\n  let n = a.length;\n  let c = n - b.length;\n  for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\n  return c;\n}\nfunction array_replace(v, a, b) {\n  let prev = 0;\n  while (true) {\n    let next = v.indexOf(a, prev);\n    if (next < 0) break;\n    v[next] = b;\n    prev = next + 1;\n  }\n}\n\n// created 2024-09-13T06:42:45.675Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a79d5f9b1879a7b416aa659f4a3d788f80a8cf5f0ab955a456592c02f556a28c\nvar COMPRESSED = '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';\n\n// https://unicode.org/reports/tr15/\n// for reference implementation\n// see: /derive/nf.js\n\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nconst S0 = 0xAC00;\nconst L0 = 0x1100;\nconst V0 = 0x1161;\nconst T0 = 0x11A7;\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst N_COUNT = V_COUNT * T_COUNT;\nconst S_COUNT = L_COUNT * N_COUNT;\nconst S1 = S0 + S_COUNT;\nconst L1 = L0 + L_COUNT;\nconst V1 = V0 + V_COUNT;\nconst T1 = T0 + T_COUNT;\nfunction unpack_cc(packed) {\n  return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n  return packed & 0xFFFFFF;\n}\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\n\n// export function nf_deinit() {\n// \tif (!SHIFTED_RANK) return;\n// \tSHIFTED_RANK = EXCLUSIONS = DECOMP = RECOMP = undefined;\n// }\n\nfunction init$1() {\n  //console.time('nf');\n  let r = read_compressed_payload(COMPRESSED);\n  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, i + 1 << 24]))); // pre-shifted\n  EXCLUSIONS = new Set(read_sorted(r));\n  DECOMP = new Map();\n  RECOMP = new Map();\n  for (let [cp, cps] of read_mapped(r)) {\n    if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n      let [a, b] = cps;\n      let bucket = RECOMP.get(a);\n      if (!bucket) {\n        bucket = new Map();\n        RECOMP.set(a, bucket);\n      }\n      bucket.set(b, cp);\n    }\n    DECOMP.set(cp, cps.reverse()); // stored reversed\n  }\n  //console.timeEnd('nf');\n  // 20230905: 11ms\n}\nfunction is_hangul(cp) {\n  return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n  if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n    return a + (b - T0);\n  } else {\n    let recomp = RECOMP.get(a);\n    if (recomp) {\n      recomp = recomp.get(b);\n      if (recomp) {\n        return recomp;\n      }\n    }\n    return -1;\n  }\n}\nfunction decomposed(cps) {\n  if (!SHIFTED_RANK) init$1();\n  let ret = [];\n  let buf = [];\n  let check_order = false;\n  function add(cp) {\n    let cc = SHIFTED_RANK.get(cp);\n    if (cc) {\n      check_order = true;\n      cp |= cc;\n    }\n    ret.push(cp);\n  }\n  for (let cp of cps) {\n    while (true) {\n      if (cp < 0x80) {\n        ret.push(cp);\n      } else if (is_hangul(cp)) {\n        let s_index = cp - S0;\n        let l_index = s_index / N_COUNT | 0;\n        let v_index = s_index % N_COUNT / T_COUNT | 0;\n        let t_index = s_index % T_COUNT;\n        add(L0 + l_index);\n        add(V0 + v_index);\n        if (t_index > 0) add(T0 + t_index);\n      } else {\n        let mapped = DECOMP.get(cp);\n        if (mapped) {\n          buf.push(...mapped);\n        } else {\n          add(cp);\n        }\n      }\n      if (!buf.length) break;\n      cp = buf.pop();\n    }\n  }\n  if (check_order && ret.length > 1) {\n    let prev_cc = unpack_cc(ret[0]);\n    for (let i = 1; i < ret.length; i++) {\n      let cc = unpack_cc(ret[i]);\n      if (cc == 0 || prev_cc <= cc) {\n        prev_cc = cc;\n        continue;\n      }\n      let j = i - 1;\n      while (true) {\n        let tmp = ret[j + 1];\n        ret[j + 1] = ret[j];\n        ret[j] = tmp;\n        if (!j) break;\n        prev_cc = unpack_cc(ret[--j]);\n        if (prev_cc <= cc) break;\n      }\n      prev_cc = unpack_cc(ret[i]);\n    }\n  }\n  return ret;\n}\nfunction composed_from_decomposed(v) {\n  let ret = [];\n  let stack = [];\n  let prev_cp = -1;\n  let prev_cc = 0;\n  for (let packed of v) {\n    let cc = unpack_cc(packed);\n    let cp = unpack_cp(packed);\n    if (prev_cp == -1) {\n      if (cc == 0) {\n        prev_cp = cp;\n      } else {\n        ret.push(cp);\n      }\n    } else if (prev_cc > 0 && prev_cc >= cc) {\n      if (cc == 0) {\n        ret.push(prev_cp, ...stack);\n        stack.length = 0;\n        prev_cp = cp;\n      } else {\n        stack.push(cp);\n      }\n      prev_cc = cc;\n    } else {\n      let composed = compose_pair(prev_cp, cp);\n      if (composed >= 0) {\n        prev_cp = composed;\n      } else if (prev_cc == 0 && cc == 0) {\n        ret.push(prev_cp);\n        prev_cp = cp;\n      } else {\n        stack.push(cp);\n        prev_cc = cc;\n      }\n    }\n  }\n  if (prev_cp >= 0) {\n    ret.push(prev_cp, ...stack);\n  }\n  return ret;\n}\n\n// note: cps can be iterable\nfunction nfd(cps) {\n  return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n  return composed_from_decomposed(decomposed(cps));\n}\nconst HYPHEN = 0x2D;\nconst STOP = 0x2E;\nconst STOP_CH = '.';\nconst FE0F = 0xFE0F;\nconst UNIQUE_PH = 1;\n\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\nconst Array_from = x => Array.from(x); // Array.from.bind(Array);\n\nfunction group_has_cp(g, cp) {\n  // 20230913: keep primary and secondary distinct instead of creating valid union\n  return g.P.has(cp) || g.Q.has(cp);\n}\nclass Emoji extends Array {\n  get is_emoji() {\n    return true;\n  } // free tagging system\n}\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\n\n// export function ens_deinit() {\n// \tnf_deinit();\n// \tif (!MAPPED) return;\n// \tMAPPED = IGNORED = CM = NSM = ESCAPE = NFC_CHECK = GROUPS = WHOLE_VALID = WHOLE_MAP = VALID = EMOJI_LIST = EMOJI_ROOT = undefined;\n// }\n\nfunction init() {\n  if (MAPPED) return;\n  let r = read_compressed_payload(COMPRESSED$1);\n  const read_sorted_array = () => read_sorted(r);\n  const read_sorted_set = () => new Set(read_sorted_array());\n  const set_add_many = (set, v) => v.forEach(x => set.add(x));\n  MAPPED = new Map(read_mapped(r));\n  IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\n\n  /*\r\n  // direct include from payload is smaller than the decompression code\r\n  const FENCED = new Map(read_array_while(() => {\r\n  \tlet cp = r();\r\n  \tif (cp) return [cp, read_str(r())];\r\n  }));\r\n  */\n  // 20230217: we still need all CM for proper error formatting\n  // but norm only needs NSM subset that are potentially-valid\n  CM = read_sorted_array();\n  NSM = new Set(read_sorted_array().map(i => CM[i]));\n  CM = new Set(CM);\n  ESCAPE = read_sorted_set(); // characters that should not be printed\n  NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\n\n  let chunks = read_sorted_arrays(r);\n  let unrestricted = r();\n  //const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\n  const read_chunked = () => {\n    // 20230921: build set in parts, 2x faster\n    let set = new Set();\n    read_sorted_array().forEach(i => set_add_many(set, chunks[i]));\n    set_add_many(set, read_sorted_array());\n    return set;\n  };\n  GROUPS = read_array_while(i => {\n    // minifier property mangling seems unsafe\n    // so these are manually renamed to single chars\n    let N = read_array_while(r).map(x => x + 0x60);\n    if (N.length) {\n      let R = i >= unrestricted; // unrestricted then restricted\n      N[0] -= 32; // capitalize\n      N = str_from_cps(N);\n      if (R) N = `Restricted[${N}]`;\n      let P = read_chunked(); // primary\n      let Q = read_chunked(); // secondary\n      let M = !r(); // not-whitelisted, check for NSM\n      // *** this code currently isn't needed ***\n      /*\r\n      let V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n      let M = r()-1; // number of combining mark\r\n      if (M < 0) { // whitelisted\r\n      \tM = new Map(read_array_while(() => {\r\n      \t\tlet i = r();\r\n      \t\tif (i) return [V[i-1], read_array_while(() => {\r\n      \t\t\tlet v = read_array_while(r);\r\n      \t\t\tif (v.length) return v.map(x => x-1);\r\n      \t\t})];\r\n      \t}));\r\n      }*/\n      return {\n        N,\n        P,\n        Q,\n        M,\n        R\n      };\n    }\n  });\n\n  // decode compressed wholes\n  WHOLE_VALID = read_sorted_set();\n  WHOLE_MAP = new Map();\n  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a - b); // must be sorted\n  wholes.forEach((cp, i) => {\n    let d = r();\n    let w = wholes[i] = d ? wholes[i - d] : {\n      V: [],\n      M: new Map()\n    };\n    w.V.push(cp); // add to member set\n    if (!WHOLE_VALID.has(cp)) {\n      WHOLE_MAP.set(cp, w); // register with whole map\n    }\n  });\n\n  // compute confusable-extent complements\n  // usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\n  for (let {\n    V,\n    M\n  } of new Set(WHOLE_MAP.values())) {\n    // connect all groups that have each whole character\n    let recs = [];\n    for (let cp of V) {\n      let gs = GROUPS.filter(g => group_has_cp(g, cp));\n      let rec = recs.find(_ref2 => {\n        let {\n          G\n        } = _ref2;\n        return gs.some(g => G.has(g));\n      });\n      if (!rec) {\n        rec = {\n          G: new Set(),\n          V: []\n        };\n        recs.push(rec);\n      }\n      rec.V.push(cp);\n      set_add_many(rec.G, gs);\n    }\n    // per character cache groups which are not a member of the extent\n    let union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole\n    for (let {\n      G,\n      V\n    } of recs) {\n      let complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent\n      for (let cp of V) {\n        M.set(cp, complement); // this is the same reference\n      }\n    }\n  }\n\n  // compute valid set\n  // 20230924: VALID was union but can be re-used\n  VALID = new Set(); // exists in 1+ groups\n  let multi = new Set(); // exists in 2+ groups\n  const add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\n  for (let g of GROUPS) {\n    for (let cp of g.P) add_to_union(cp);\n    for (let cp of g.Q) add_to_union(cp);\n  }\n  // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n  for (let cp of VALID) {\n    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n      WHOLE_MAP.set(cp, UNIQUE_PH);\n    }\n  }\n  // add all decomposed parts\n  // see derive: \"Valid is Closed (via Brute-force)\"\n  set_add_many(VALID, nfd(VALID));\n\n  // decode emoji\n  // 20230719: emoji are now fully-expanded to avoid quirk logic \n  EMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);\n  EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\n  for (let cps of EMOJI_LIST) {\n    // 20230719: change to *slightly* stricter algorithm which disallows \n    // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\n    // example: beautified [A B] (eg. flag emoji) \n    //  before: allow: [A FE0F B], error: [A FE0F FE0F B] \n    //   after: error: both\n    // note: this code now matches ENSNormalize.{cs,java} logic\n    let prev = [EMOJI_ROOT];\n    for (let cp of cps) {\n      let next = prev.map(node => {\n        let child = node.get(cp);\n        if (!child) {\n          // should this be object? \n          // (most have 1-2 items, few have many)\n          // 20230719: no, v8 default map is 4?\n          child = new Map();\n          node.set(cp, child);\n        }\n        return child;\n      });\n      if (cp === FE0F) {\n        prev.push(...next); // less than 20 elements\n      } else {\n        prev = next;\n      }\n    }\n    for (let x of prev) {\n      x.V = cps;\n    }\n  }\n}\n\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n  return (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\n}\n\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n  return `\"${s}\"\\u200E`; // strong LTR\n}\nfunction check_label_extension(cps) {\n  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n    throw new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\n  }\n}\nfunction check_leading_underscore(cps) {\n  const UNDERSCORE = 0x5F;\n  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0;) {\n    if (cps[--i] !== UNDERSCORE) {\n      throw new Error('underscore allowed only at start');\n    }\n  }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n  let cp = cps[0];\n  let prev = FENCED.get(cp);\n  if (prev) throw error_placement(`leading ${prev}`);\n  let n = cps.length;\n  let last = -1; // prevents trailing from throwing\n  for (let i = 1; i < n; i++) {\n    cp = cps[i];\n    let match = FENCED.get(cp);\n    if (match) {\n      // since cps[0] isn't fenced, cps[1] cannot throw\n      if (last == i) throw error_placement(`${prev} + ${match}`);\n      last = i + 1;\n      prev = match;\n    }\n  }\n  if (last == n) throw error_placement(`trailing ${prev}`);\n}\n\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// if cps exceed max, middle truncate with ellipsis\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps) {\n  let max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  let quoter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : quote_cp;\n  //if (Number.isInteger(cps)) cps = [cps];\n  //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n  let buf = [];\n  if (is_combining_mark(cps[0])) buf.push('â—Œ');\n  if (cps.length > max) {\n    max >>= 1;\n    cps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];\n  }\n  let prev = 0;\n  let n = cps.length;\n  for (let i = 0; i < n; i++) {\n    let cp = cps[i];\n    if (should_escape(cp)) {\n      buf.push(str_from_cps(cps.slice(prev, i)));\n      buf.push(quoter(cp));\n      prev = i + 1;\n    }\n  }\n  buf.push(str_from_cps(cps.slice(prev, n)));\n  return buf.join('');\n}\n\n// note: set(s) cannot be exposed because they can be modified\n// note: Object.freeze() doesn't work\nfunction is_combining_mark(cp, only_nsm) {\n  // 20240127: add extra argument\n  init();\n  return only_nsm ? NSM.has(cp) : CM.has(cp);\n}\nfunction should_escape(cp) {\n  init();\n  return ESCAPE.has(cp);\n}\n\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n  init();\n  return EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy\n}\nfunction ens_normalize_fragment(frag, decompose) {\n  init();\n  let nf = decompose ? nfd : nfc;\n  return frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n  return flatten(split(name, nfc, filter_fe0f));\n}\nfunction ens_beautify(name) {\n  let labels = split(name, nfc, x => x); // emoji not exposed\n  for (let {\n    type,\n    output,\n    error\n  } of labels) {\n    if (error) break; // flatten will throw\n\n    // replace leading/trailing hyphen\n    // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n    // not exactly the same in every font, but very similar: \"-\" vs \"â€\"\n    /*\r\n    const UNICODE_HYPHEN = 0x2010;\r\n    // maybe this should replace all for visual consistancy?\r\n    // `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n    //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n    if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n    let end = output.length-1;\r\n    if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n    */\n    // 20230123: WHATWG URL uses \"CheckHyphens\" false\n    // https://url.spec.whatwg.org/#idna\n\n    // update ethereum symbol\n    // Î¾ => Îž if not greek\n    if (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);\n\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\n    //output.splice(0, 0, 0x200E);\n  }\n  return flatten(labels);\n}\nfunction ens_split(name, preserve_emoji) {\n  return split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy\n}\nfunction split(name, nf, ef) {\n  if (!name) return []; // 20230719: empty name allowance\n  init();\n  let offset = 0;\n  // https://unicode.org/reports/tr46/#Validity_Criteria\n  // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n  return name.split(STOP_CH).map(label => {\n    let input = explode_cp(label);\n    let info = {\n      input,\n      offset // codepoint, not substring!\n    };\n    offset += input.length + 1; // + stop\n    try {\n      // 1.) \"The label must be in Unicode Normalization Form NFC\"\n      let tokens = info.tokens = tokens_from_str(input, nf, ef);\n      let token_count = tokens.length;\n      let type;\n      if (!token_count) {\n        // the label was effectively empty (could of had ignored characters)\n        //norm = [];\n        //type = 'None'; // use this instead of next match, \"ASCII\"\n        // 20230120: change to strict\n        // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n        throw new Error(`empty label`);\n      }\n      let norm = info.output = tokens.flat();\n      check_leading_underscore(norm);\n      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\n      if (!emoji && norm.every(cp => cp < 0x80)) {\n        // special case for ascii\n        // 20230123: matches matches WHATWG, see note 3.3\n        check_label_extension(norm); // only needed for ascii\n        // cant have fenced\n        // cant have cm\n        // cant have wholes\n        // see derive: \"Fastpath ASCII\"\n        type = 'ASCII';\n      } else {\n        let chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\n        if (!chars.length) {\n          // theres no text, just emoji\n          type = 'Emoji';\n        } else {\n          // 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n          if (CM.has(norm[0])) throw error_placement('leading combining mark');\n          for (let i = 1; i < token_count; i++) {\n            // we've already checked the first token\n            let cps = tokens[i];\n            if (!cps.is_emoji && CM.has(cps[0])) {\n              // every text token has emoji neighbors, eg. EtEEEtEt...\n              // bidi_qq() not needed since emoji is LTR and cps is a CM\n              throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}\"`);\n            }\n          }\n          check_fenced(norm);\n          let unique = Array_from(new Set(chars));\n          let [g] = determine_group(unique); // take the first match\n          // see derive: \"Matching Groups have Same CM Style\"\n          // alternative: could form a hybrid type: Latin/Japanese/...\t\n          check_group(g, chars); // need text in order\n          check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n          type = g.N;\n          // 20230121: consider exposing restricted flag\n          // it's simpler to just check for 'Restricted'\n          // or even better: type.endsWith(']')\n          //if (g.R) info.restricted = true;\n        }\n      }\n      info.type = type;\n    } catch (err) {\n      info.error = err; // use full error object\n    }\n    return info;\n  });\n}\nfunction check_whole(group, unique) {\n  let maker;\n  let shared = [];\n  for (let cp of unique) {\n    let whole = WHOLE_MAP.get(cp);\n    if (whole === UNIQUE_PH) return; // unique, non-confusable\n    if (whole) {\n      let set = whole.M.get(cp); // groups which have a character that look-like this character\n      maker = maker ? maker.filter(g => set.has(g)) : Array_from(set);\n      if (!maker.length) return; // confusable intersection is empty\n    } else {\n      shared.push(cp);\n    }\n  }\n  if (maker) {\n    // we have 1+ confusable\n    // check if any of the remaining groups\n    // contain the shared characters too\n    for (let g of maker) {\n      if (shared.every(cp => group_has_cp(g, cp))) {\n        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);\n      }\n    }\n  }\n}\n\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n  let groups = GROUPS;\n  for (let cp of unique) {\n    // note: we need to dodge CM that are whitelisted\n    // but that code isn't currently necessary\n    let gs = groups.filter(g => group_has_cp(g, cp));\n    if (!gs.length) {\n      if (!GROUPS.some(g => group_has_cp(g, cp))) {\n        // the character was composed of valid parts\n        // but it's NFC form is invalid\n        // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\n        // note: this doesn't have to be a composition\n        // 20230720: change to full check\n        throw error_disallowed(cp); // this should be rare\n      } else {\n        // there is no group that contains all these characters\n        // throw using the highest priority group that matched\n        // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n        throw error_group_member(groups[0], cp);\n      }\n    }\n    groups = gs;\n    if (gs.length == 1) break; // there is only one group left\n  }\n  // there are at least 1 group(s) with all of these characters\n  return groups;\n}\n\n// throw on first error\nfunction flatten(split) {\n  return split.map(_ref3 => {\n    let {\n      input,\n      error,\n      output\n    } = _ref3;\n    if (error) {\n      // don't print label again if just a single label\n      let msg = error.message;\n      // bidi_qq() only necessary if msg is digits\n      throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);\n    }\n    return str_from_cps(output);\n  }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n  // TODO: add cp to error?\n  return new Error(`disallowed character: ${quoted_cp(cp)}`);\n}\nfunction error_group_member(g, cp) {\n  let quoted = quoted_cp(cp);\n  let gg = GROUPS.find(g => g.P.has(cp)); // only check primary\n  if (gg) {\n    quoted = `${gg.N} ${quoted}`;\n  }\n  return new Error(`illegal mixture: ${g.N} + ${quoted}`);\n}\nfunction error_placement(where) {\n  return new Error(`illegal placement: ${where}`);\n}\n\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n  for (let cp of cps) {\n    if (!group_has_cp(g, cp)) {\n      // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n      // at the moment, it's unnecessary to introduce an extra error type\n      // until there exists a whitelisted multi-character\n      //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n      // there are 3 cases:\n      //   1. illegal cm for wrong group => mixture error\n      //   2. illegal cm for same group => cm error\n      //       requires set of whitelist cm per group: \n      //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\n      //   3. wrong group => mixture error\n      throw error_group_member(g, cp);\n    }\n  }\n  //if (M >= 0) { // we have a known fixed cm count\n  if (g.M) {\n    // we need to check for NSM\n    let decomposed = nfd(cps);\n    for (let i = 1, e = decomposed.length; i < e; i++) {\n      // see: assumption\n      // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n      /*\r\n      if (CM.has(decomposed[i])) {\r\n      \tlet j = i + 1;\r\n      \twhile (j < e && CM.has(decomposed[j])) j++;\r\n      \tif (j - i > M) {\r\n      \t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n      \t}\r\n      \ti = j;\r\n      }\r\n      */\n      // 20230217: switch to NSM counting\n      // https://www.unicode.org/reports/tr39/#Optional_Detection\n      if (NSM.has(decomposed[i])) {\n        let j = i + 1;\n        for (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\n          // a. Forbid sequences of the same nonspacing mark.\n          for (let k = i; k < j; k++) {\n            // O(n^2) but n < 100\n            if (decomposed[k] == cp) {\n              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\n            }\n          }\n        }\n        // parse to end so we have full nsm count\n        // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n        if (j - i > NSM_MAX) {\n          // note: this slice starts with a base char or spacing-mark cm\n          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);\n        }\n        i = j;\n      }\n    }\n  }\n  // *** this code currently isn't needed ***\n  /*\r\n  let cm_whitelist = M instanceof Map;\r\n  for (let i = 0, e = cps.length; i < e; ) {\r\n  \tlet cp = cps[i++];\r\n  \tlet seqs = cm_whitelist && M.get(cp);\r\n  \tif (seqs) { \r\n  \t\t// list of codepoints that can follow\r\n  \t\t// if this exists, this will always be 1+\r\n  \t\tlet j = i;\r\n  \t\twhile (j < e && CM.has(cps[j])) j++;\r\n  \t\tlet cms = cps.slice(i, j);\r\n  \t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n  \t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n  \t\ti = j;\r\n  \t} else if (!V.has(cp)) {\r\n  \t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n  \t\tlet quoted = quoted_cp(cp);\r\n  \t\tfor (let cp of cps) {\r\n  \t\t\tlet u = UNIQUE.get(cp);\r\n  \t\t\tif (u && u !== g) {\r\n  \t\t\t\t// if both scripts are restricted this error is confusing\r\n  \t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n  \t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n  \t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n  \t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n  \t}\r\n  }\r\n  if (!cm_whitelist) {\r\n  \tlet decomposed = nfd(cps);\r\n  \tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n  \t\tif (CM.has(decomposed[i])) {\r\n  \t\t\tlet j = i + 1;\r\n  \t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n  \t\t\tif (j - i > M) {\r\n  \t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n  \t\t\t}\r\n  \t\t\ti = j;\r\n  \t\t}\r\n  \t}\r\n  }\r\n  */\n}\n\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abcðŸ’©d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\n// 20230818: rename for 'process' name collision h/t Javarome\n// https://github.com/adraffy/ens-normalize.js/issues/23\nfunction tokens_from_str(input, nf, ef) {\n  let ret = [];\n  let chars = [];\n  input = input.slice().reverse(); // flip so we can pop\n  while (input.length) {\n    let emoji = consume_emoji_reversed(input);\n    if (emoji) {\n      if (chars.length) {\n        ret.push(nf(chars));\n        chars = [];\n      }\n      ret.push(ef(emoji));\n    } else {\n      let cp = input.pop();\n      if (VALID.has(cp)) {\n        chars.push(cp);\n      } else {\n        let cps = MAPPED.get(cp);\n        if (cps) {\n          chars.push(...cps); // less than 10 elements\n        } else if (!IGNORED.has(cp)) {\n          // 20230912: unicode 15.1 changed the order of processing such that\n          // disallowed parts are only rejected after NFC\n          // https://unicode.org/reports/tr46/#Validity_Criteria\n          // this doesn't impact normalization as of today\n          // technically, this error can be removed as the group logic will apply similar logic\n          // however the error type might be less clear\n          throw error_disallowed(cp);\n        }\n      }\n    }\n  }\n  if (chars.length) {\n    ret.push(nf(chars));\n  }\n  return ret;\n}\nfunction filter_fe0f(cps) {\n  return cps.filter(cp => cp != FE0F);\n}\n\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n  let node = EMOJI_ROOT;\n  let emoji;\n  let pos = cps.length;\n  while (pos) {\n    node = node.get(cps[--pos]);\n    if (!node) break;\n    let {\n      V\n    } = node;\n    if (V) {\n      // this is a valid emoji (so far)\n      emoji = V;\n      if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\n      cps.length = pos; // truncate\n    }\n  }\n  return emoji;\n}\n\n// ************************************************************\n// tokenizer \n\nconst TY_VALID = 'valid';\nconst TY_MAPPED = 'mapped';\nconst TY_IGNORED = 'ignored';\nconst TY_DISALLOWED = 'disallowed';\nconst TY_EMOJI = 'emoji';\nconst TY_NFC = 'nfc';\nconst TY_STOP = 'stop';\nfunction ens_tokenize(name) {\n  let {\n    nf = true // collapse unnormalized runs into a single token\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  init();\n  let input = explode_cp(name).reverse();\n  let eaten = [];\n  let tokens = [];\n  while (input.length) {\n    let emoji = consume_emoji_reversed(input, eaten);\n    if (emoji) {\n      tokens.push({\n        type: TY_EMOJI,\n        emoji: emoji.slice(),\n        // copy emoji\n        input: eaten,\n        cps: filter_fe0f(emoji)\n      });\n      eaten = []; // reset buffer\n    } else {\n      let cp = input.pop();\n      if (cp == STOP) {\n        tokens.push({\n          type: TY_STOP,\n          cp\n        });\n      } else if (VALID.has(cp)) {\n        tokens.push({\n          type: TY_VALID,\n          cps: [cp]\n        });\n      } else if (IGNORED.has(cp)) {\n        tokens.push({\n          type: TY_IGNORED,\n          cp\n        });\n      } else {\n        let cps = MAPPED.get(cp);\n        if (cps) {\n          tokens.push({\n            type: TY_MAPPED,\n            cp,\n            cps: cps.slice()\n          });\n        } else {\n          tokens.push({\n            type: TY_DISALLOWED,\n            cp\n          });\n        }\n      }\n    }\n  }\n  if (nf) {\n    for (let i = 0, start = -1; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (is_valid_or_mapped(token.type)) {\n        if (requires_check(token.cps)) {\n          // normalization might be needed\n          let end = i + 1;\n          for (let pos = end; pos < tokens.length; pos++) {\n            // find adjacent text\n            let {\n              type,\n              cps\n            } = tokens[pos];\n            if (is_valid_or_mapped(type)) {\n              if (!requires_check(cps)) break;\n              end = pos + 1;\n            } else if (type !== TY_IGNORED) {\n              // || type !== TY_DISALLOWED) { \n              break;\n            }\n          }\n          if (start < 0) start = i;\n          let slice = tokens.slice(start, end);\n          let cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n          let cps = nfc(cps0);\n          if (compare_arrays(cps, cps0)) {\n            // bundle into an nfc token\n            tokens.splice(start, end - start, {\n              type: TY_NFC,\n              input: cps0,\n              // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\n              cps,\n              tokens0: collapse_valid_tokens(slice),\n              tokens: ens_tokenize(str_from_cps(cps), {\n                nf: false\n              })\n            });\n            i = start;\n          } else {\n            i = end - 1; // skip to end of slice\n          }\n          start = -1; // reset\n        } else {\n          start = i; // remember last\n        }\n      } else if (token.type !== TY_IGNORED) {\n        // 20221024: is this correct?\n        start = -1; // reset\n      }\n    }\n  }\n  return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n  return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n  return cps.some(cp => NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n  for (let i = 0; i < tokens.length; i++) {\n    if (tokens[i].type == TY_VALID) {\n      let j = i + 1;\n      while (j < tokens.length && tokens[j].type == TY_VALID) j++;\n      tokens.splice(i, j - i, {\n        type: TY_VALID,\n        cps: tokens.slice(i, j).flatMap(x => x.cps)\n      });\n    }\n  }\n  return tokens;\n}\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };","map":{"version":3,"names":["COMPRESSED$1","FENCED","Map","NSM_MAX","decode_arithmetic","bytes","pos","u16","symbol_count","total","acc","i","push","skip","pos_payload","read_width","read_buffer","read_bit","N","FULL","HALF","QRTR","MASK","register","symbols","low","range","value","Math","floor","start","end","mid","a","b","offset","map","x","read_payload","v","read_compressed_payload","s","unsafe_atob","lookup","forEach","c","charCodeAt","n","length","ret","Uint8Array","width","carry","signed","read_deltas","next","Array","read_sorted","prev","arguments","undefined","read_sorted_arrays","read_array_while","read_mapped","w","read_linear_table","read_replacement_table","flat","read_transposed","m","fill","j","dx","dy","vN","flatMap","ys","_","j_dy","y","slice","read_trie","sorted","expand","decode","Q","S","B","cps","_ref","saved","br","cp","hex_cp","toString","toUpperCase","padStart","quote_cp","explode_cp","len","codePointAt","str_from_cps","chunk","String","fromCodePoint","buf","join","compare_arrays","array_replace","indexOf","COMPRESSED","S0","L0","V0","T0","L_COUNT","V_COUNT","T_COUNT","N_COUNT","S_COUNT","S1","L1","V1","T1","unpack_cc","packed","unpack_cp","SHIFTED_RANK","EXCLUSIONS","DECOMP","RECOMP","init$1","r","Set","has","bucket","get","set","reverse","is_hangul","compose_pair","recomp","decomposed","check_order","add","cc","s_index","l_index","v_index","t_index","mapped","pop","prev_cc","tmp","composed_from_decomposed","stack","prev_cp","composed","nfd","nfc","HYPHEN","STOP","STOP_CH","FE0F","UNIQUE_PH","Array_from","from","group_has_cp","g","P","Emoji","is_emoji","MAPPED","IGNORED","CM","NSM","ESCAPE","NFC_CHECK","GROUPS","WHOLE_VALID","WHOLE_MAP","VALID","EMOJI_LIST","EMOJI_ROOT","init","read_sorted_array","read_sorted_set","set_add_many","chunks","unrestricted","read_chunked","R","M","wholes","concat","sort","d","V","values","recs","gs","filter","rec","find","_ref2","G","some","union","complement","multi","add_to_union","node","child","quoted_cp","should_escape","bidi_qq","safe_str_from_cps","check_label_extension","Error","check_leading_underscore","UNDERSCORE","lastIndexOf","check_fenced","error_placement","last","match","max","Infinity","quoter","is_combining_mark","only_nsm","ens_emoji","ens_normalize_fragment","frag","decompose","nf","split","label","tokens_from_str","filter_fe0f","ens_normalize","name","flatten","ens_beautify","labels","type","output","error","ens_split","preserve_emoji","ef","input","info","tokens","token_count","norm","emoji","every","chars","unique","determine_group","check_group","check_whole","err","group","maker","shared","whole","groups","error_disallowed","error_group_member","_ref3","msg","message","quoted","gg","where","e","k","consume_emoji_reversed","eaten","TY_VALID","TY_MAPPED","TY_IGNORED","TY_DISALLOWED","TY_EMOJI","TY_NFC","TY_STOP","ens_tokenize","token","is_valid_or_mapped","requires_check","cps0","splice","tokens0","collapse_valid_tokens"],"sources":["C:/Users/deanw/OneDrive/Desktop/GitHub/tribepacks/node_modules/@adraffy/ens-normalize/dist/index.mjs"],"sourcesContent":["// created 2024-09-13T06:42:45.675Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0ca3917bee1eee342d64c631cb1dbaac37b167d848887d59f6d68328dc99ac09\nvar COMPRESSED$1 = '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';\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\r\n\r\n\r\nfunction read_trie(next) {\r\n\tlet ret = [];\r\n\tlet sorted = read_sorted(next); \r\n\texpand(decode([]), []);\r\n\treturn ret; // not sorted\r\n\tfunction decode(Q) { // characters that lead into this node\r\n\t\tlet S = next(); // state: valid, save, check\r\n\t\tlet B = read_array_while(() => { // buckets leading to new nodes\r\n\t\t\tlet cps = read_sorted(next).map(i => sorted[i]);\r\n\t\t\tif (cps.length) return decode(cps);\r\n\t\t});\r\n\t\treturn {S, B, Q};\r\n\t}\r\n\tfunction expand({S, B}, cps, saved) {\r\n\t\tif (S & 4 && saved === cps[cps.length-1]) return;\r\n\t\tif (S & 2) saved = cps[cps.length-1];\r\n\t\tif (S & 1) ret.push(cps); \r\n\t\tfor (let br of B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\texpand(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\r\n\r\nfunction array_replace(v, a, b) {\r\n\tlet prev = 0;\r\n\twhile (true) {\r\n\t\tlet next = v.indexOf(a, prev);\r\n\t\tif (next < 0) break;\r\n\t\tv[next] = b; \r\n\t\tprev = next + 1;\r\n\t}\r\n}\n\n// created 2024-09-13T06:42:45.675Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a79d5f9b1879a7b416aa659f4a3d788f80a8cf5f0ab955a456592c02f556a28c\nvar COMPRESSED = 'AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA';\n\n// https://unicode.org/reports/tr15/\r\n// for reference implementation\r\n// see: /derive/nf.js\r\n\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\r\n\r\n// export function nf_deinit() {\r\n// \tif (!SHIFTED_RANK) return;\r\n// \tSHIFTED_RANK = EXCLUSIONS = DECOMP = RECOMP = undefined;\r\n// }\r\n\r\nfunction init$1() {\r\n\t//console.time('nf');\r\n\tlet r = read_compressed_payload(COMPRESSED);\r\n\tSHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\n\tEXCLUSIONS = new Set(read_sorted(r));\r\n\tDECOMP = new Map();\r\n\tRECOMP = new Map();\r\n\tfor (let [cp, cps] of read_mapped(r)) {\r\n\t\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\t\tlet [a, b] = cps;\r\n\t\t\tlet bucket = RECOMP.get(a);\r\n\t\t\tif (!bucket) {\r\n\t\t\t\tbucket = new Map();\r\n\t\t\t\tRECOMP.set(a, bucket);\r\n\t\t\t}\r\n\t\t\tbucket.set(b, cp);\r\n\t\t}\r\n\t\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n\t}\r\n\t//console.timeEnd('nf');\r\n\t// 20230905: 11ms\r\n}\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tif (!SHIFTED_RANK) init$1();\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\nconst HYPHEN = 0x2D;\r\nconst STOP = 0x2E;\r\nconst STOP_CH = '.';\r\nconst FE0F = 0xFE0F;\r\nconst UNIQUE_PH = 1;\r\n\r\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\r\nconst Array_from = x => Array.from(x); // Array.from.bind(Array);\r\n\r\nfunction group_has_cp(g, cp) {\r\n\t// 20230913: keep primary and secondary distinct instead of creating valid union\r\n\treturn g.P.has(cp) || g.Q.has(cp);\r\n}\r\n\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; } // free tagging system\r\n}\r\n\r\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\r\n\r\n// export function ens_deinit() {\r\n// \tnf_deinit();\r\n// \tif (!MAPPED) return;\r\n// \tMAPPED = IGNORED = CM = NSM = ESCAPE = NFC_CHECK = GROUPS = WHOLE_VALID = WHOLE_MAP = VALID = EMOJI_LIST = EMOJI_ROOT = undefined;\r\n// }\r\n\r\nfunction init() {\r\n\tif (MAPPED) return;\r\n\t\r\n\tlet r = read_compressed_payload(COMPRESSED$1);\r\n\tconst read_sorted_array = () => read_sorted(r);\r\n\tconst read_sorted_set = () => new Set(read_sorted_array());\r\n\tconst set_add_many = (set, v) => v.forEach(x => set.add(x));\r\n\r\n\tMAPPED = new Map(read_mapped(r)); \r\n\tIGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\r\n\r\n\t/*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/\r\n\t// 20230217: we still need all CM for proper error formatting\r\n\t// but norm only needs NSM subset that are potentially-valid\r\n\tCM = read_sorted_array();\r\n\tNSM = new Set(read_sorted_array().map(i => CM[i]));\r\n\tCM = new Set(CM);\r\n\t\r\n\tESCAPE = read_sorted_set(); // characters that should not be printed\r\n\tNFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\r\n\r\n\tlet chunks = read_sorted_arrays(r);\r\n\tlet unrestricted = r();\r\n\t//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\r\n\tconst read_chunked = () => {\r\n\t\t// 20230921: build set in parts, 2x faster\r\n\t\tlet set = new Set();\r\n\t\tread_sorted_array().forEach(i => set_add_many(set, chunks[i]));\r\n\t\tset_add_many(set, read_sorted_array());\r\n\t\treturn set; \r\n\t};\r\n\tGROUPS = read_array_while(i => {\r\n\t\t// minifier property mangling seems unsafe\r\n\t\t// so these are manually renamed to single chars\r\n\t\tlet N = read_array_while(r).map(x => x+0x60);\r\n\t\tif (N.length) {\r\n\t\t\tlet R = i >= unrestricted; // unrestricted then restricted\r\n\t\t\tN[0] -= 32; // capitalize\r\n\t\t\tN = str_from_cps(N);\r\n\t\t\tif (R) N=`Restricted[${N}]`;\r\n\t\t\tlet P = read_chunked(); // primary\r\n\t\t\tlet Q = read_chunked(); // secondary\r\n\t\t\tlet M = !r(); // not-whitelisted, check for NSM\r\n\t\t\t// *** this code currently isn't needed ***\r\n\t\t\t/*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/\r\n\t\t\treturn {N, P, Q, M, R};\r\n\t\t}\r\n\t});\r\n\r\n\t// decode compressed wholes\r\n\tWHOLE_VALID = read_sorted_set();\r\n\tWHOLE_MAP = new Map();\r\n\tlet wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted\r\n\twholes.forEach((cp, i) => {\r\n\t\tlet d = r(); \r\n\t\tlet w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};\r\n\t\tw.V.push(cp); // add to member set\r\n\t\tif (!WHOLE_VALID.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t\t}\r\n\t});\r\n\r\n\t// compute confusable-extent complements\r\n\t// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\r\n\tfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t\t// connect all groups that have each whole character\r\n\t\tlet recs = [];\r\n\t\tfor (let cp of V) {\r\n\t\t\tlet gs = GROUPS.filter(g => group_has_cp(g, cp));\r\n\t\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\t\tif (!rec) {\r\n\t\t\t\trec = {G: new Set(), V: []};\r\n\t\t\t\trecs.push(rec);\r\n\t\t\t}\r\n\t\t\trec.V.push(cp);\r\n\t\t\tset_add_many(rec.G, gs);\r\n\t\t}\r\n\t\t// per character cache groups which are not a member of the extent\r\n\t\tlet union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole\r\n\t\tfor (let {G, V} of recs) {\r\n\t\t\tlet complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent\r\n\t\t\tfor (let cp of V) {\r\n\t\t\t\tM.set(cp, complement); // this is the same reference\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// compute valid set\r\n\t// 20230924: VALID was union but can be re-used\r\n\tVALID = new Set(); // exists in 1+ groups\r\n\tlet multi = new Set(); // exists in 2+ groups\r\n\tconst add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\r\n\tfor (let g of GROUPS) {\r\n\t\tfor (let cp of g.P) add_to_union(cp);\r\n\t\tfor (let cp of g.Q) add_to_union(cp);\r\n\t}\r\n\t// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\n\tfor (let cp of VALID) {\r\n\t\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t\t}\r\n\t}\r\n\t// add all decomposed parts\r\n\t// see derive: \"Valid is Closed (via Brute-force)\"\r\n\tset_add_many(VALID, nfd(VALID));\r\n\t\r\n\t// decode emoji\r\n\t// 20230719: emoji are now fully-expanded to avoid quirk logic \r\n\tEMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);\r\n\tEMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\r\n\tfor (let cps of EMOJI_LIST) {\r\n\t\t// 20230719: change to *slightly* stricter algorithm which disallows \r\n\t\t// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\r\n\t\t// example: beautified [A B] (eg. flag emoji) \r\n\t\t//  before: allow: [A FE0F B], error: [A FE0F FE0F B] \r\n\t\t//   after: error: both\r\n\t\t// note: this code now matches ENSNormalize.{cs,java} logic\r\n\t\tlet prev = [EMOJI_ROOT];\r\n\t\tfor (let cp of cps) {\r\n\t\t\tlet next = prev.map(node => {\r\n\t\t\t\tlet child = node.get(cp);\r\n\t\t\t\tif (!child) {\r\n\t\t\t\t\t// should this be object? \r\n\t\t\t\t\t// (most have 1-2 items, few have many)\r\n\t\t\t\t\t// 20230719: no, v8 default map is 4?\r\n\t\t\t\t\tchild = new Map();\r\n\t\t\t\t\tnode.set(cp, child);\r\n\t\t\t\t}\r\n\t\t\t\treturn child;\r\n\t\t\t});\r\n\t\t\tif (cp === FE0F) {\r\n\t\t\t\tprev.push(...next); // less than 20 elements\r\n\t\t\t} else {\r\n\t\t\t\tprev = next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let x of prev) {\r\n\t\t\tx.V = cps;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// if cps exceed max, middle truncate with ellipsis\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('â—Œ');\r\n\tif (cps.length > max) {\r\n\t\tmax >>= 1;\r\n\t\tcps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];\r\n\t}\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\n// note: Object.freeze() doesn't work\r\nfunction is_combining_mark(cp, only_nsm) { // 20240127: add extra argument\r\n\tinit();\r\n\treturn only_nsm ? NSM.has(cp) : CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\tinit();\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\tinit();\r\n\treturn EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tinit();\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(split(name, nfc, filter_fe0f));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet labels = split(name, nfc, x => x); // emoji not exposed\r\n\tfor (let {type, output, error} of labels) {\r\n\t\tif (error) break; // flatten will throw\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"â€\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// Î¾ => Îž if not greek\r\n\t\tif (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(labels);\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\treturn split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy\r\n}\r\n\r\nfunction split(name, nf, ef) {\r\n\tif (!name) return []; // 20230719: empty name allowance\r\n\tinit();\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = tokens_from_str(input, nf, ef);\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} \r\n\t\t\tlet norm = info.output = tokens.flat();\r\n\t\t\tcheck_leading_underscore(norm);\r\n\t\t\tlet emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\r\n\t\t\tif (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\tcheck_label_extension(norm); // only needed for ascii\r\n\t\t\t\t// cant have fenced\r\n\t\t\t\t// cant have cm\r\n\t\t\t\t// cant have wholes\r\n\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\ttype = 'ASCII';\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\tlet unique = Array_from(new Set(chars));\r\n\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = [];\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : Array_from(set);\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaining groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => group_has_cp(g, cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => group_has_cp(g, cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (!GROUPS.some(g => group_has_cp(g, cp))) { \r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\t// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\r\n\t\t\t\t// note: this doesn't have to be a composition\r\n\t\t\t\t// 20230720: change to full check\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp)); // only check primary\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tfor (let cp of cps) {\r\n\t\tif (!group_has_cp(g, cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (g.M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abcðŸ’©d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\n// 20230818: rename for 'process' name collision h/t Javarome\r\n// https://github.com/adraffy/ens-normalize.js/issues/23\r\nfunction tokens_from_str(input, nf, ef) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(ef(emoji));\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps); // less than 10 elements\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\t// 20230912: unicode 15.1 changed the order of processing such that\r\n\t\t\t\t\t// disallowed parts are only rejected after NFC\r\n\t\t\t\t\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t\t\t\t\t// this doesn't impact normalization as of today\r\n\t\t\t\t\t// technically, this error can be removed as the group logic will apply similar logic\r\n\t\t\t\t\t// however the error type might be less clear\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet pos = cps.length;\r\n\twhile (pos) {\r\n\t\tnode = node.get(cps[--pos]);\r\n\t\tif (!node) break;\r\n\t\tlet {V} = node;\r\n\t\tif (V) { // this is a valid emoji (so far)\r\n\t\t\temoji = V;\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\treturn emoji;\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tinit();\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TY_EMOJI,\r\n\t\t\t\temoji: emoji.slice(), // copy emoji\r\n\t\t\t\tinput: eaten,\r\n\t\t\t\tcps: filter_fe0f(emoji)\r\n\t\t\t});\r\n\t\t\teaten = []; // reset buffer\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}